/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace IManagement {
  export type CreatorStruct = {
    escrow: PromiseOrValue<string>;
    isAllowed: PromiseOrValue<boolean>;
  };

  export type CreatorStructOutput = [string, boolean] & {
    escrow: string;
    isAllowed: boolean;
  };

  export type CrowdFundParamsStruct = {
    valuesLowQuota: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ];
    valuesRegQuota: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ];
    valuesHighQuota: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ];
    amountLowQuota: PromiseOrValue<BigNumberish>;
    amountRegQuota: PromiseOrValue<BigNumberish>;
    amountHighQuota: PromiseOrValue<BigNumberish>;
    donationReceiver: PromiseOrValue<string>;
    donationFee: PromiseOrValue<BigNumberish>;
    minSoldRate: PromiseOrValue<BigNumberish>;
    crowdfundDuration: PromiseOrValue<BigNumberish>;
  };

  export type CrowdFundParamsStructOutput = [
    [BigNumber, BigNumber, BigNumber],
    [BigNumber, BigNumber, BigNumber],
    [BigNumber, BigNumber, BigNumber],
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    valuesLowQuota: [BigNumber, BigNumber, BigNumber];
    valuesRegQuota: [BigNumber, BigNumber, BigNumber];
    valuesHighQuota: [BigNumber, BigNumber, BigNumber];
    amountLowQuota: BigNumber;
    amountRegQuota: BigNumber;
    amountHighQuota: BigNumber;
    donationReceiver: string;
    donationFee: BigNumber;
    minSoldRate: BigNumber;
    crowdfundDuration: BigNumber;
  };
}

export interface ManagementInterface extends utils.Interface {
  functions: {
    "getBeaconAdminArt()": FunctionFragment;
    "getBeaconAdminCreators()": FunctionFragment;
    "getBeaconAdminFund()": FunctionFragment;
    "getBeaconAdminStaking()": FunctionFragment;
    "getCollections(address)": FunctionFragment;
    "getCreator(address)": FunctionFragment;
    "getFee()": FunctionFragment;
    "getImplementation()": FunctionFragment;
    "getIsCorrupted(address)": FunctionFragment;
    "getManagers(address)": FunctionFragment;
    "getMultiSig()": FunctionFragment;
    "getProxyReward()": FunctionFragment;
    "getStakingCollections(address)": FunctionFragment;
    "getTokenContract(uint8)": FunctionFragment;
    "initialize(address,address,address,address,address)": FunctionFragment;
    "newArtCollection(string,string,uint256,uint256,uint256,uint256,string,uint256)": FunctionFragment;
    "newArtCollection(string,string,uint256,uint256,uint256,uint256,string,uint256,address)": FunctionFragment;
    "newCRPStaking(address,uint256,uint256[3])": FunctionFragment;
    "newCRPStaking(address,uint256,uint256[3],address)": FunctionFragment;
    "newCreatorsCollection(string,string,uint256,uint256,uint256,uint256,string)": FunctionFragment;
    "newCrowdfund(string,string,string,uint256,address,(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256))": FunctionFragment;
    "newCrowdfund(string,string,string,uint256,(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256))": FunctionFragment;
    "pause()": FunctionFragment;
    "paused()": FunctionFragment;
    "proxiableUUID()": FunctionFragment;
    "setBeaconAdminArt(address)": FunctionFragment;
    "setBeaconAdminCreators(address)": FunctionFragment;
    "setBeaconAdminFund(address)": FunctionFragment;
    "setBeaconAdminStaking(address)": FunctionFragment;
    "setCollections(address,bool)": FunctionFragment;
    "setCorrupted(address,bool)": FunctionFragment;
    "setCreator(address,bool)": FunctionFragment;
    "setManager(address,bool)": FunctionFragment;
    "setMultiSig(address)": FunctionFragment;
    "setProxyReward(address)": FunctionFragment;
    "setTokenContract(uint8,address)": FunctionFragment;
    "unpause()": FunctionFragment;
    "upgradeTo(address)": FunctionFragment;
    "upgradeToAndCall(address,bytes)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "getBeaconAdminArt"
      | "getBeaconAdminCreators"
      | "getBeaconAdminFund"
      | "getBeaconAdminStaking"
      | "getCollections"
      | "getCreator"
      | "getFee"
      | "getImplementation"
      | "getIsCorrupted"
      | "getManagers"
      | "getMultiSig"
      | "getProxyReward"
      | "getStakingCollections"
      | "getTokenContract"
      | "initialize"
      | "newArtCollection(string,string,uint256,uint256,uint256,uint256,string,uint256)"
      | "newArtCollection(string,string,uint256,uint256,uint256,uint256,string,uint256,address)"
      | "newCRPStaking(address,uint256,uint256[3])"
      | "newCRPStaking(address,uint256,uint256[3],address)"
      | "newCreatorsCollection"
      | "newCrowdfund(string,string,string,uint256,address,(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256))"
      | "newCrowdfund(string,string,string,uint256,(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256))"
      | "pause"
      | "paused"
      | "proxiableUUID"
      | "setBeaconAdminArt"
      | "setBeaconAdminCreators"
      | "setBeaconAdminFund"
      | "setBeaconAdminStaking"
      | "setCollections"
      | "setCorrupted"
      | "setCreator"
      | "setManager"
      | "setMultiSig"
      | "setProxyReward"
      | "setTokenContract"
      | "unpause"
      | "upgradeTo"
      | "upgradeToAndCall"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "getBeaconAdminArt",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBeaconAdminCreators",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBeaconAdminFund",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBeaconAdminStaking",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getCollections",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getCreator",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "getFee", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getImplementation",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getIsCorrupted",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getManagers",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getMultiSig",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getProxyReward",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getStakingCollections",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenContract",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "newArtCollection(string,string,uint256,uint256,uint256,uint256,string,uint256)",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "newArtCollection(string,string,uint256,uint256,uint256,uint256,string,uint256,address)",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "newCRPStaking(address,uint256,uint256[3])",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "newCRPStaking(address,uint256,uint256[3],address)",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "newCreatorsCollection",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "newCrowdfund(string,string,string,uint256,address,(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256))",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      IManagement.CrowdFundParamsStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "newCrowdfund(string,string,string,uint256,(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256))",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      IManagement.CrowdFundParamsStruct
    ]
  ): string;
  encodeFunctionData(functionFragment: "pause", values?: undefined): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "proxiableUUID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setBeaconAdminArt",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setBeaconAdminCreators",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setBeaconAdminFund",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setBeaconAdminStaking",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setCollections",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setCorrupted",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setCreator",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setManager",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMultiSig",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setProxyReward",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setTokenContract",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "upgradeTo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeToAndCall",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;

  decodeFunctionResult(
    functionFragment: "getBeaconAdminArt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBeaconAdminCreators",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBeaconAdminFund",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBeaconAdminStaking",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCollections",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getCreator", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getFee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getImplementation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getIsCorrupted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getManagers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMultiSig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProxyReward",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStakingCollections",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenContract",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "newArtCollection(string,string,uint256,uint256,uint256,uint256,string,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "newArtCollection(string,string,uint256,uint256,uint256,uint256,string,uint256,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "newCRPStaking(address,uint256,uint256[3])",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "newCRPStaking(address,uint256,uint256[3],address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "newCreatorsCollection",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "newCrowdfund(string,string,string,uint256,address,(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256))",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "newCrowdfund(string,string,string,uint256,(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256))",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proxiableUUID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setBeaconAdminArt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setBeaconAdminCreators",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setBeaconAdminFund",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setBeaconAdminStaking",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setCollections",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setCorrupted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setCreator", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setManager", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setMultiSig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setProxyReward",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTokenContract",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "upgradeTo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "upgradeToAndCall",
    data: BytesLike
  ): Result;

  events: {
    "AdminChanged(address,address)": EventFragment;
    "ArtCollection(address,address,address)": EventFragment;
    "BeaconUpgraded(address)": EventFragment;
    "CRPStaking(address,address,address)": EventFragment;
    "CollectionSet(address,bool)": EventFragment;
    "CorruptedAddressSet(address,address,bool)": EventFragment;
    "CreatorSet(address,bool,address)": EventFragment;
    "CreatorsCollection(address,address)": EventFragment;
    "Crowdfund(address,address,address,address)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "ManagerSet(address,bool,address)": EventFragment;
    "NewBeaconAdminArt(address,address)": EventFragment;
    "NewBeaconAdminCreators(address,address)": EventFragment;
    "NewBeaconAdminFund(address,address)": EventFragment;
    "NewBeaconAdminStaking(address,address)": EventFragment;
    "NewMultiSig(address,address)": EventFragment;
    "NewProxyReward(address,address)": EventFragment;
    "Paused(address)": EventFragment;
    "TokenContractSet(address,address,uint8)": EventFragment;
    "Unpaused(address)": EventFragment;
    "Upgraded(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AdminChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ArtCollection"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BeaconUpgraded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CRPStaking"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CollectionSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CorruptedAddressSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CreatorSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CreatorsCollection"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Crowdfund"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ManagerSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewBeaconAdminArt"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewBeaconAdminCreators"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewBeaconAdminFund"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewBeaconAdminStaking"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewMultiSig"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewProxyReward"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokenContractSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Upgraded"): EventFragment;
}

export interface AdminChangedEventObject {
  previousAdmin: string;
  newAdmin: string;
}
export type AdminChangedEvent = TypedEvent<
  [string, string],
  AdminChangedEventObject
>;

export type AdminChangedEventFilter = TypedEventFilter<AdminChangedEvent>;

export interface ArtCollectionEventObject {
  collection: string;
  creator: string;
  caller: string;
}
export type ArtCollectionEvent = TypedEvent<
  [string, string, string],
  ArtCollectionEventObject
>;

export type ArtCollectionEventFilter = TypedEventFilter<ArtCollectionEvent>;

export interface BeaconUpgradedEventObject {
  beacon: string;
}
export type BeaconUpgradedEvent = TypedEvent<
  [string],
  BeaconUpgradedEventObject
>;

export type BeaconUpgradedEventFilter = TypedEventFilter<BeaconUpgradedEvent>;

export interface CRPStakingEventObject {
  staking: string;
  creator: string;
  caller: string;
}
export type CRPStakingEvent = TypedEvent<
  [string, string, string],
  CRPStakingEventObject
>;

export type CRPStakingEventFilter = TypedEventFilter<CRPStakingEvent>;

export interface CollectionSetEventObject {
  collection: string;
  set: boolean;
}
export type CollectionSetEvent = TypedEvent<
  [string, boolean],
  CollectionSetEventObject
>;

export type CollectionSetEventFilter = TypedEventFilter<CollectionSetEvent>;

export interface CorruptedAddressSetEventObject {
  manager: string;
  creator: string;
  corrupted: boolean;
}
export type CorruptedAddressSetEvent = TypedEvent<
  [string, string, boolean],
  CorruptedAddressSetEventObject
>;

export type CorruptedAddressSetEventFilter =
  TypedEventFilter<CorruptedAddressSetEvent>;

export interface CreatorSetEventObject {
  creator: string;
  allowed: boolean;
  manager: string;
}
export type CreatorSetEvent = TypedEvent<
  [string, boolean, string],
  CreatorSetEventObject
>;

export type CreatorSetEventFilter = TypedEventFilter<CreatorSetEvent>;

export interface CreatorsCollectionEventObject {
  collection: string;
  creator: string;
}
export type CreatorsCollectionEvent = TypedEvent<
  [string, string],
  CreatorsCollectionEventObject
>;

export type CreatorsCollectionEventFilter =
  TypedEventFilter<CreatorsCollectionEvent>;

export interface CrowdfundEventObject {
  fundCollection: string;
  artCollection: string;
  creator: string;
  caller: string;
}
export type CrowdfundEvent = TypedEvent<
  [string, string, string, string],
  CrowdfundEventObject
>;

export type CrowdfundEventFilter = TypedEventFilter<CrowdfundEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface ManagerSetEventObject {
  setManager: string;
  allowed: boolean;
  manager: string;
}
export type ManagerSetEvent = TypedEvent<
  [string, boolean, string],
  ManagerSetEventObject
>;

export type ManagerSetEventFilter = TypedEventFilter<ManagerSetEvent>;

export interface NewBeaconAdminArtEventObject {
  beacon: string;
  manager: string;
}
export type NewBeaconAdminArtEvent = TypedEvent<
  [string, string],
  NewBeaconAdminArtEventObject
>;

export type NewBeaconAdminArtEventFilter =
  TypedEventFilter<NewBeaconAdminArtEvent>;

export interface NewBeaconAdminCreatorsEventObject {
  beacon: string;
  manager: string;
}
export type NewBeaconAdminCreatorsEvent = TypedEvent<
  [string, string],
  NewBeaconAdminCreatorsEventObject
>;

export type NewBeaconAdminCreatorsEventFilter =
  TypedEventFilter<NewBeaconAdminCreatorsEvent>;

export interface NewBeaconAdminFundEventObject {
  beacon: string;
  manager: string;
}
export type NewBeaconAdminFundEvent = TypedEvent<
  [string, string],
  NewBeaconAdminFundEventObject
>;

export type NewBeaconAdminFundEventFilter =
  TypedEventFilter<NewBeaconAdminFundEvent>;

export interface NewBeaconAdminStakingEventObject {
  beacon: string;
  manager: string;
}
export type NewBeaconAdminStakingEvent = TypedEvent<
  [string, string],
  NewBeaconAdminStakingEventObject
>;

export type NewBeaconAdminStakingEventFilter =
  TypedEventFilter<NewBeaconAdminStakingEvent>;

export interface NewMultiSigEventObject {
  multisig: string;
  manager: string;
}
export type NewMultiSigEvent = TypedEvent<
  [string, string],
  NewMultiSigEventObject
>;

export type NewMultiSigEventFilter = TypedEventFilter<NewMultiSigEvent>;

export interface NewProxyRewardEventObject {
  proxy: string;
  manager: string;
}
export type NewProxyRewardEvent = TypedEvent<
  [string, string],
  NewProxyRewardEventObject
>;

export type NewProxyRewardEventFilter = TypedEventFilter<NewProxyRewardEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface TokenContractSetEventObject {
  manager: string;
  token: string;
  coin: number;
}
export type TokenContractSetEvent = TypedEvent<
  [string, string, number],
  TokenContractSetEventObject
>;

export type TokenContractSetEventFilter =
  TypedEventFilter<TokenContractSetEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface UpgradedEventObject {
  implementation: string;
}
export type UpgradedEvent = TypedEvent<[string], UpgradedEventObject>;

export type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;

export interface Management extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ManagementInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    getBeaconAdminArt(overrides?: CallOverrides): Promise<[string]>;

    getBeaconAdminCreators(overrides?: CallOverrides): Promise<[string]>;

    getBeaconAdminFund(overrides?: CallOverrides): Promise<[string]>;

    getBeaconAdminStaking(overrides?: CallOverrides): Promise<[string]>;

    getCollections(
      collection: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    getCreator(
      creator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[IManagement.CreatorStructOutput]>;

    getFee(overrides?: CallOverrides): Promise<[BigNumber]>;

    getImplementation(overrides?: CallOverrides): Promise<[string]>;

    getIsCorrupted(
      creator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    getManagers(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    getMultiSig(overrides?: CallOverrides): Promise<[string]>;

    getProxyReward(overrides?: CallOverrides): Promise<[string]>;

    getStakingCollections(
      collection: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    getTokenContract(
      coin: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    initialize(
      beaconAdminArt: PromiseOrValue<string>,
      beaconAdminFund: PromiseOrValue<string>,
      beaconAdminCreators: PromiseOrValue<string>,
      erc20USD: PromiseOrValue<string>,
      multiSig: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "newArtCollection(string,string,uint256,uint256,uint256,uint256,string,uint256)"(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      maxSupply: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      priceInUSD: PromiseOrValue<BigNumberish>,
      priceInCreatorsCoin: PromiseOrValue<BigNumberish>,
      baseURI: PromiseOrValue<string>,
      royalty: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "newArtCollection(string,string,uint256,uint256,uint256,uint256,string,uint256,address)"(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      maxSupply: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      priceInUSD: PromiseOrValue<BigNumberish>,
      priceInCreatorsCoin: PromiseOrValue<BigNumberish>,
      baseURI: PromiseOrValue<string>,
      royalty: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "newCRPStaking(address,uint256,uint256[3])"(
      stakingToken: PromiseOrValue<string>,
      timeUnit: PromiseOrValue<BigNumberish>,
      rewardsPerUnitTime: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "newCRPStaking(address,uint256,uint256[3],address)"(
      stakingToken: PromiseOrValue<string>,
      timeUnit: PromiseOrValue<BigNumberish>,
      rewardsPerUnitTime: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    newCreatorsCollection(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      maxSupply: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      priceInUSDC: PromiseOrValue<BigNumberish>,
      priceInCreatorsCoin: PromiseOrValue<BigNumberish>,
      baseURI: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "newCrowdfund(string,string,string,uint256,address,(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256))"(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      baseURI: PromiseOrValue<string>,
      royalty: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      cfParams: IManagement.CrowdFundParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "newCrowdfund(string,string,string,uint256,(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256))"(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      baseURI: PromiseOrValue<string>,
      royalty: PromiseOrValue<BigNumberish>,
      cfParams: IManagement.CrowdFundParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    pause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    proxiableUUID(overrides?: CallOverrides): Promise<[string]>;

    setBeaconAdminArt(
      beacon: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setBeaconAdminCreators(
      beacon: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setBeaconAdminFund(
      beacon: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setBeaconAdminStaking(
      beacon: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setCollections(
      collection: PromiseOrValue<string>,
      set: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setCorrupted(
      creator: PromiseOrValue<string>,
      corrupted: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setCreator(
      creator: PromiseOrValue<string>,
      allowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setManager(
      manager: PromiseOrValue<string>,
      allowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMultiSig(
      multisig: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setProxyReward(
      proxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setTokenContract(
      coin: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  getBeaconAdminArt(overrides?: CallOverrides): Promise<string>;

  getBeaconAdminCreators(overrides?: CallOverrides): Promise<string>;

  getBeaconAdminFund(overrides?: CallOverrides): Promise<string>;

  getBeaconAdminStaking(overrides?: CallOverrides): Promise<string>;

  getCollections(
    collection: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getCreator(
    creator: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<IManagement.CreatorStructOutput>;

  getFee(overrides?: CallOverrides): Promise<BigNumber>;

  getImplementation(overrides?: CallOverrides): Promise<string>;

  getIsCorrupted(
    creator: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getManagers(
    caller: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getMultiSig(overrides?: CallOverrides): Promise<string>;

  getProxyReward(overrides?: CallOverrides): Promise<string>;

  getStakingCollections(
    collection: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getTokenContract(
    coin: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  initialize(
    beaconAdminArt: PromiseOrValue<string>,
    beaconAdminFund: PromiseOrValue<string>,
    beaconAdminCreators: PromiseOrValue<string>,
    erc20USD: PromiseOrValue<string>,
    multiSig: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "newArtCollection(string,string,uint256,uint256,uint256,uint256,string,uint256)"(
    name: PromiseOrValue<string>,
    symbol: PromiseOrValue<string>,
    maxSupply: PromiseOrValue<BigNumberish>,
    price: PromiseOrValue<BigNumberish>,
    priceInUSD: PromiseOrValue<BigNumberish>,
    priceInCreatorsCoin: PromiseOrValue<BigNumberish>,
    baseURI: PromiseOrValue<string>,
    royalty: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "newArtCollection(string,string,uint256,uint256,uint256,uint256,string,uint256,address)"(
    name: PromiseOrValue<string>,
    symbol: PromiseOrValue<string>,
    maxSupply: PromiseOrValue<BigNumberish>,
    price: PromiseOrValue<BigNumberish>,
    priceInUSD: PromiseOrValue<BigNumberish>,
    priceInCreatorsCoin: PromiseOrValue<BigNumberish>,
    baseURI: PromiseOrValue<string>,
    royalty: PromiseOrValue<BigNumberish>,
    owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "newCRPStaking(address,uint256,uint256[3])"(
    stakingToken: PromiseOrValue<string>,
    timeUnit: PromiseOrValue<BigNumberish>,
    rewardsPerUnitTime: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "newCRPStaking(address,uint256,uint256[3],address)"(
    stakingToken: PromiseOrValue<string>,
    timeUnit: PromiseOrValue<BigNumberish>,
    rewardsPerUnitTime: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ],
    owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  newCreatorsCollection(
    name: PromiseOrValue<string>,
    symbol: PromiseOrValue<string>,
    maxSupply: PromiseOrValue<BigNumberish>,
    price: PromiseOrValue<BigNumberish>,
    priceInUSDC: PromiseOrValue<BigNumberish>,
    priceInCreatorsCoin: PromiseOrValue<BigNumberish>,
    baseURI: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "newCrowdfund(string,string,string,uint256,address,(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256))"(
    name: PromiseOrValue<string>,
    symbol: PromiseOrValue<string>,
    baseURI: PromiseOrValue<string>,
    royalty: PromiseOrValue<BigNumberish>,
    owner: PromiseOrValue<string>,
    cfParams: IManagement.CrowdFundParamsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "newCrowdfund(string,string,string,uint256,(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256))"(
    name: PromiseOrValue<string>,
    symbol: PromiseOrValue<string>,
    baseURI: PromiseOrValue<string>,
    royalty: PromiseOrValue<BigNumberish>,
    cfParams: IManagement.CrowdFundParamsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  pause(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  proxiableUUID(overrides?: CallOverrides): Promise<string>;

  setBeaconAdminArt(
    beacon: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setBeaconAdminCreators(
    beacon: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setBeaconAdminFund(
    beacon: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setBeaconAdminStaking(
    beacon: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setCollections(
    collection: PromiseOrValue<string>,
    set: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setCorrupted(
    creator: PromiseOrValue<string>,
    corrupted: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setCreator(
    creator: PromiseOrValue<string>,
    allowed: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setManager(
    manager: PromiseOrValue<string>,
    allowed: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMultiSig(
    multisig: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setProxyReward(
    proxy: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setTokenContract(
    coin: PromiseOrValue<BigNumberish>,
    token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unpause(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeTo(
    newImplementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  upgradeToAndCall(
    newImplementation: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    getBeaconAdminArt(overrides?: CallOverrides): Promise<string>;

    getBeaconAdminCreators(overrides?: CallOverrides): Promise<string>;

    getBeaconAdminFund(overrides?: CallOverrides): Promise<string>;

    getBeaconAdminStaking(overrides?: CallOverrides): Promise<string>;

    getCollections(
      collection: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getCreator(
      creator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<IManagement.CreatorStructOutput>;

    getFee(overrides?: CallOverrides): Promise<BigNumber>;

    getImplementation(overrides?: CallOverrides): Promise<string>;

    getIsCorrupted(
      creator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getManagers(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getMultiSig(overrides?: CallOverrides): Promise<string>;

    getProxyReward(overrides?: CallOverrides): Promise<string>;

    getStakingCollections(
      collection: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getTokenContract(
      coin: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    initialize(
      beaconAdminArt: PromiseOrValue<string>,
      beaconAdminFund: PromiseOrValue<string>,
      beaconAdminCreators: PromiseOrValue<string>,
      erc20USD: PromiseOrValue<string>,
      multiSig: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    "newArtCollection(string,string,uint256,uint256,uint256,uint256,string,uint256)"(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      maxSupply: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      priceInUSD: PromiseOrValue<BigNumberish>,
      priceInCreatorsCoin: PromiseOrValue<BigNumberish>,
      baseURI: PromiseOrValue<string>,
      royalty: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    "newArtCollection(string,string,uint256,uint256,uint256,uint256,string,uint256,address)"(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      maxSupply: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      priceInUSD: PromiseOrValue<BigNumberish>,
      priceInCreatorsCoin: PromiseOrValue<BigNumberish>,
      baseURI: PromiseOrValue<string>,
      royalty: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    "newCRPStaking(address,uint256,uint256[3])"(
      stakingToken: PromiseOrValue<string>,
      timeUnit: PromiseOrValue<BigNumberish>,
      rewardsPerUnitTime: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      overrides?: CallOverrides
    ): Promise<void>;

    "newCRPStaking(address,uint256,uint256[3],address)"(
      stakingToken: PromiseOrValue<string>,
      timeUnit: PromiseOrValue<BigNumberish>,
      rewardsPerUnitTime: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    newCreatorsCollection(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      maxSupply: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      priceInUSDC: PromiseOrValue<BigNumberish>,
      priceInCreatorsCoin: PromiseOrValue<BigNumberish>,
      baseURI: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    "newCrowdfund(string,string,string,uint256,address,(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256))"(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      baseURI: PromiseOrValue<string>,
      royalty: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      cfParams: IManagement.CrowdFundParamsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    "newCrowdfund(string,string,string,uint256,(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256))"(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      baseURI: PromiseOrValue<string>,
      royalty: PromiseOrValue<BigNumberish>,
      cfParams: IManagement.CrowdFundParamsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    pause(overrides?: CallOverrides): Promise<void>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    proxiableUUID(overrides?: CallOverrides): Promise<string>;

    setBeaconAdminArt(
      beacon: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setBeaconAdminCreators(
      beacon: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setBeaconAdminFund(
      beacon: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setBeaconAdminStaking(
      beacon: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setCollections(
      collection: PromiseOrValue<string>,
      set: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setCorrupted(
      creator: PromiseOrValue<string>,
      corrupted: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setCreator(
      creator: PromiseOrValue<string>,
      allowed: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setManager(
      manager: PromiseOrValue<string>,
      allowed: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMultiSig(
      multisig: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setProxyReward(
      proxy: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setTokenContract(
      coin: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    unpause(overrides?: CallOverrides): Promise<void>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "AdminChanged(address,address)"(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;
    AdminChanged(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;

    "ArtCollection(address,address,address)"(
      collection?: PromiseOrValue<string> | null,
      creator?: PromiseOrValue<string> | null,
      caller?: PromiseOrValue<string> | null
    ): ArtCollectionEventFilter;
    ArtCollection(
      collection?: PromiseOrValue<string> | null,
      creator?: PromiseOrValue<string> | null,
      caller?: PromiseOrValue<string> | null
    ): ArtCollectionEventFilter;

    "BeaconUpgraded(address)"(
      beacon?: PromiseOrValue<string> | null
    ): BeaconUpgradedEventFilter;
    BeaconUpgraded(
      beacon?: PromiseOrValue<string> | null
    ): BeaconUpgradedEventFilter;

    "CRPStaking(address,address,address)"(
      staking?: PromiseOrValue<string> | null,
      creator?: PromiseOrValue<string> | null,
      caller?: PromiseOrValue<string> | null
    ): CRPStakingEventFilter;
    CRPStaking(
      staking?: PromiseOrValue<string> | null,
      creator?: PromiseOrValue<string> | null,
      caller?: PromiseOrValue<string> | null
    ): CRPStakingEventFilter;

    "CollectionSet(address,bool)"(
      collection?: PromiseOrValue<string> | null,
      set?: null
    ): CollectionSetEventFilter;
    CollectionSet(
      collection?: PromiseOrValue<string> | null,
      set?: null
    ): CollectionSetEventFilter;

    "CorruptedAddressSet(address,address,bool)"(
      manager?: PromiseOrValue<string> | null,
      creator?: PromiseOrValue<string> | null,
      corrupted?: null
    ): CorruptedAddressSetEventFilter;
    CorruptedAddressSet(
      manager?: PromiseOrValue<string> | null,
      creator?: PromiseOrValue<string> | null,
      corrupted?: null
    ): CorruptedAddressSetEventFilter;

    "CreatorSet(address,bool,address)"(
      creator?: PromiseOrValue<string> | null,
      allowed?: null,
      manager?: PromiseOrValue<string> | null
    ): CreatorSetEventFilter;
    CreatorSet(
      creator?: PromiseOrValue<string> | null,
      allowed?: null,
      manager?: PromiseOrValue<string> | null
    ): CreatorSetEventFilter;

    "CreatorsCollection(address,address)"(
      collection?: PromiseOrValue<string> | null,
      creator?: PromiseOrValue<string> | null
    ): CreatorsCollectionEventFilter;
    CreatorsCollection(
      collection?: PromiseOrValue<string> | null,
      creator?: PromiseOrValue<string> | null
    ): CreatorsCollectionEventFilter;

    "Crowdfund(address,address,address,address)"(
      fundCollection?: PromiseOrValue<string> | null,
      artCollection?: PromiseOrValue<string> | null,
      creator?: PromiseOrValue<string> | null,
      caller?: null
    ): CrowdfundEventFilter;
    Crowdfund(
      fundCollection?: PromiseOrValue<string> | null,
      artCollection?: PromiseOrValue<string> | null,
      creator?: PromiseOrValue<string> | null,
      caller?: null
    ): CrowdfundEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "ManagerSet(address,bool,address)"(
      setManager?: PromiseOrValue<string> | null,
      allowed?: null,
      manager?: PromiseOrValue<string> | null
    ): ManagerSetEventFilter;
    ManagerSet(
      setManager?: PromiseOrValue<string> | null,
      allowed?: null,
      manager?: PromiseOrValue<string> | null
    ): ManagerSetEventFilter;

    "NewBeaconAdminArt(address,address)"(
      beacon?: PromiseOrValue<string> | null,
      manager?: PromiseOrValue<string> | null
    ): NewBeaconAdminArtEventFilter;
    NewBeaconAdminArt(
      beacon?: PromiseOrValue<string> | null,
      manager?: PromiseOrValue<string> | null
    ): NewBeaconAdminArtEventFilter;

    "NewBeaconAdminCreators(address,address)"(
      beacon?: PromiseOrValue<string> | null,
      manager?: PromiseOrValue<string> | null
    ): NewBeaconAdminCreatorsEventFilter;
    NewBeaconAdminCreators(
      beacon?: PromiseOrValue<string> | null,
      manager?: PromiseOrValue<string> | null
    ): NewBeaconAdminCreatorsEventFilter;

    "NewBeaconAdminFund(address,address)"(
      beacon?: PromiseOrValue<string> | null,
      manager?: PromiseOrValue<string> | null
    ): NewBeaconAdminFundEventFilter;
    NewBeaconAdminFund(
      beacon?: PromiseOrValue<string> | null,
      manager?: PromiseOrValue<string> | null
    ): NewBeaconAdminFundEventFilter;

    "NewBeaconAdminStaking(address,address)"(
      beacon?: PromiseOrValue<string> | null,
      manager?: PromiseOrValue<string> | null
    ): NewBeaconAdminStakingEventFilter;
    NewBeaconAdminStaking(
      beacon?: PromiseOrValue<string> | null,
      manager?: PromiseOrValue<string> | null
    ): NewBeaconAdminStakingEventFilter;

    "NewMultiSig(address,address)"(
      multisig?: PromiseOrValue<string> | null,
      manager?: PromiseOrValue<string> | null
    ): NewMultiSigEventFilter;
    NewMultiSig(
      multisig?: PromiseOrValue<string> | null,
      manager?: PromiseOrValue<string> | null
    ): NewMultiSigEventFilter;

    "NewProxyReward(address,address)"(
      proxy?: PromiseOrValue<string> | null,
      manager?: PromiseOrValue<string> | null
    ): NewProxyRewardEventFilter;
    NewProxyReward(
      proxy?: PromiseOrValue<string> | null,
      manager?: PromiseOrValue<string> | null
    ): NewProxyRewardEventFilter;

    "Paused(address)"(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    "TokenContractSet(address,address,uint8)"(
      manager?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      coin?: null
    ): TokenContractSetEventFilter;
    TokenContractSet(
      manager?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      coin?: null
    ): TokenContractSetEventFilter;

    "Unpaused(address)"(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;

    "Upgraded(address)"(
      implementation?: PromiseOrValue<string> | null
    ): UpgradedEventFilter;
    Upgraded(
      implementation?: PromiseOrValue<string> | null
    ): UpgradedEventFilter;
  };

  estimateGas: {
    getBeaconAdminArt(overrides?: CallOverrides): Promise<BigNumber>;

    getBeaconAdminCreators(overrides?: CallOverrides): Promise<BigNumber>;

    getBeaconAdminFund(overrides?: CallOverrides): Promise<BigNumber>;

    getBeaconAdminStaking(overrides?: CallOverrides): Promise<BigNumber>;

    getCollections(
      collection: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCreator(
      creator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getFee(overrides?: CallOverrides): Promise<BigNumber>;

    getImplementation(overrides?: CallOverrides): Promise<BigNumber>;

    getIsCorrupted(
      creator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getManagers(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMultiSig(overrides?: CallOverrides): Promise<BigNumber>;

    getProxyReward(overrides?: CallOverrides): Promise<BigNumber>;

    getStakingCollections(
      collection: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTokenContract(
      coin: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      beaconAdminArt: PromiseOrValue<string>,
      beaconAdminFund: PromiseOrValue<string>,
      beaconAdminCreators: PromiseOrValue<string>,
      erc20USD: PromiseOrValue<string>,
      multiSig: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "newArtCollection(string,string,uint256,uint256,uint256,uint256,string,uint256)"(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      maxSupply: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      priceInUSD: PromiseOrValue<BigNumberish>,
      priceInCreatorsCoin: PromiseOrValue<BigNumberish>,
      baseURI: PromiseOrValue<string>,
      royalty: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "newArtCollection(string,string,uint256,uint256,uint256,uint256,string,uint256,address)"(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      maxSupply: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      priceInUSD: PromiseOrValue<BigNumberish>,
      priceInCreatorsCoin: PromiseOrValue<BigNumberish>,
      baseURI: PromiseOrValue<string>,
      royalty: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "newCRPStaking(address,uint256,uint256[3])"(
      stakingToken: PromiseOrValue<string>,
      timeUnit: PromiseOrValue<BigNumberish>,
      rewardsPerUnitTime: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "newCRPStaking(address,uint256,uint256[3],address)"(
      stakingToken: PromiseOrValue<string>,
      timeUnit: PromiseOrValue<BigNumberish>,
      rewardsPerUnitTime: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    newCreatorsCollection(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      maxSupply: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      priceInUSDC: PromiseOrValue<BigNumberish>,
      priceInCreatorsCoin: PromiseOrValue<BigNumberish>,
      baseURI: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "newCrowdfund(string,string,string,uint256,address,(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256))"(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      baseURI: PromiseOrValue<string>,
      royalty: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      cfParams: IManagement.CrowdFundParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "newCrowdfund(string,string,string,uint256,(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256))"(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      baseURI: PromiseOrValue<string>,
      royalty: PromiseOrValue<BigNumberish>,
      cfParams: IManagement.CrowdFundParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    pause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    proxiableUUID(overrides?: CallOverrides): Promise<BigNumber>;

    setBeaconAdminArt(
      beacon: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setBeaconAdminCreators(
      beacon: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setBeaconAdminFund(
      beacon: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setBeaconAdminStaking(
      beacon: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setCollections(
      collection: PromiseOrValue<string>,
      set: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setCorrupted(
      creator: PromiseOrValue<string>,
      corrupted: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setCreator(
      creator: PromiseOrValue<string>,
      allowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setManager(
      manager: PromiseOrValue<string>,
      allowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMultiSig(
      multisig: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setProxyReward(
      proxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setTokenContract(
      coin: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    getBeaconAdminArt(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getBeaconAdminCreators(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBeaconAdminFund(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBeaconAdminStaking(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCollections(
      collection: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCreator(
      creator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getImplementation(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getIsCorrupted(
      creator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getManagers(
      caller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMultiSig(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getProxyReward(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getStakingCollections(
      collection: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTokenContract(
      coin: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      beaconAdminArt: PromiseOrValue<string>,
      beaconAdminFund: PromiseOrValue<string>,
      beaconAdminCreators: PromiseOrValue<string>,
      erc20USD: PromiseOrValue<string>,
      multiSig: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "newArtCollection(string,string,uint256,uint256,uint256,uint256,string,uint256)"(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      maxSupply: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      priceInUSD: PromiseOrValue<BigNumberish>,
      priceInCreatorsCoin: PromiseOrValue<BigNumberish>,
      baseURI: PromiseOrValue<string>,
      royalty: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "newArtCollection(string,string,uint256,uint256,uint256,uint256,string,uint256,address)"(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      maxSupply: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      priceInUSD: PromiseOrValue<BigNumberish>,
      priceInCreatorsCoin: PromiseOrValue<BigNumberish>,
      baseURI: PromiseOrValue<string>,
      royalty: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "newCRPStaking(address,uint256,uint256[3])"(
      stakingToken: PromiseOrValue<string>,
      timeUnit: PromiseOrValue<BigNumberish>,
      rewardsPerUnitTime: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "newCRPStaking(address,uint256,uint256[3],address)"(
      stakingToken: PromiseOrValue<string>,
      timeUnit: PromiseOrValue<BigNumberish>,
      rewardsPerUnitTime: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<BigNumberish>
      ],
      owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    newCreatorsCollection(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      maxSupply: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      priceInUSDC: PromiseOrValue<BigNumberish>,
      priceInCreatorsCoin: PromiseOrValue<BigNumberish>,
      baseURI: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "newCrowdfund(string,string,string,uint256,address,(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256))"(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      baseURI: PromiseOrValue<string>,
      royalty: PromiseOrValue<BigNumberish>,
      owner: PromiseOrValue<string>,
      cfParams: IManagement.CrowdFundParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "newCrowdfund(string,string,string,uint256,(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256))"(
      name: PromiseOrValue<string>,
      symbol: PromiseOrValue<string>,
      baseURI: PromiseOrValue<string>,
      royalty: PromiseOrValue<BigNumberish>,
      cfParams: IManagement.CrowdFundParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    pause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proxiableUUID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setBeaconAdminArt(
      beacon: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setBeaconAdminCreators(
      beacon: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setBeaconAdminFund(
      beacon: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setBeaconAdminStaking(
      beacon: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setCollections(
      collection: PromiseOrValue<string>,
      set: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setCorrupted(
      creator: PromiseOrValue<string>,
      corrupted: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setCreator(
      creator: PromiseOrValue<string>,
      allowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setManager(
      manager: PromiseOrValue<string>,
      allowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMultiSig(
      multisig: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setProxyReward(
      proxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setTokenContract(
      coin: PromiseOrValue<BigNumberish>,
      token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
